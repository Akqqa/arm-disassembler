TODO:

- BUGFIX based on allTest.s! its perfect it shows you every single bug. currently look into ldrb_reg.xml and why it isnt being matched!
- BUG: defining which asm template to use based on value of certain variables e.g https://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/LDRB--register---Load-Register-Byte--register--?lang=en
- can be cases where no "" in paragraph or encodedin, in this case use symbol e.g lsl
  This is actually just outside of the scope really. this occurs in aliases, when the value is described in the "is equivalent to text" with its own logic, very complex to add for things that only account for 26 / ~2000 = 0.013% of instructions
  - most others seem to be aliases with the out-of-scope parsing to figure out values - NOTE: this isnt even easier with pseudocode! just bad documentation that can easily be made better if instead it says smth like "encoded in 31 minus imms"
  - casp: uses W(s+1) so takes the already known Ws from Rs and adds 1 to it, tricky to hard code for
  - for st1q_za_p_rrr.xml, the xml just says "is the offset 0", whereas the html says "with implicit value 0". see if redownloading files changes this to match. if not falt of the spec as not machine readable enough
- proper exit conditions
- replace 31 with ZR or SP depending on instruction!
- EVALUATION - a good comparison could be to https://binary.ninja/2021/04/05/groundup-aarch64.html

- huh, pickling a stripped down encoding table that doesnt store methods ends up being the same size and time to unpickle? okay

strangely objdump isnt working? mine is? weird

DONE:
- add explanation to instructionpage class (?)
  -note that explanations can require docvars of the encodings etc.
  - ACTUALLY!!! each explanation has an "enclist" which is the list of encodings it maps to!
  so we simply have to for each explanation check the encoings it applies to and place them in that encoding!
  assumes that expalnations are per class not page - will check this
  no - explanations are per page
  SO, once everything is made, the page can read explanations. for each it will serach through all encodings and add each explanations to the ones they match :)
  https://developer.arm.com/documentation/ddi0602/2023-09/Base-Instructions/AND--immediate---Bitwise-AND--immediate--?lang=en
  - see and_log_shift.xml for example of standard table - 1to1 mapping ebtwen var and value 
- MANY of the explanations have plaintext such as "encoded as "Zn" times 2 plus 1" etc.
  occasionally with field before the times
  fmlsl_za_zzi for example.
  add checks to translate this into maths expression and perform these on the digits to get right decoding
  even has modulo!

  https://developer.arm.com/documentation/ddi0602/2023-12/SIMD-FP-Instructions/ST3--single-structure---Store-single-3-element-structure-from-one-lane-of-three-registers-
  THIS is an instructon with the equations that is not locked behind a FEAT!
- mov's have "implicit value 0/1" etc! can hard code for this
 - bitmask immediate, if this is detected in the paragraph description, decode as a bitmask immediate, which is described here: https://kddnewton.com/2022/08/11/aarch64-bitmask-immediates.html

- proper alias treatment - LOOK INTO ALIASPREF section ininstruction page except FOR PS STUFF
- add special case in explanation decoding for imm5<4:1> to treat it as 4:1st digits of imm5 rather than just imm5<4 ++ 1>
  ^ using regex search, all table entries seem to be normal without extra stuff such as imm5<4:1>:h:Rd etc.
  extremely complex edge case: msr_imm and all related xmls. pseudocode is extremely complex and textual encodings rely on additional factors out of scope - simply cant really do this correctly at this current time
  another edge case: rprfm_reg, where the pseudocode doesnt help and the xml description is very complex and impossible to parse! lots of cases! 
  this is a limitation of the program therefore, BUT it does contain option<2>:option<0>:S:Rt<2:0> indicating this should be supported in case of other interactions

  now, it splits correctly, just have to make it actually accound for the imm5<4:1> stuff properly now in and outside tables



-imm5<4:1> MEANS TAKE THE BITS BETWEEN INCLUSIVE! NOT CONCATENATE!!



Example hand reverse disassembly:
mul x4, x2, x5
Convering to machine code based on spec:
It is equivalent to MADD, However, this is just for when disassembling, and we are doing the opposite.
10011011000Rm011111RnRd
Rm is 5, so 00101
Rn is 2, so 00010
Rd is 4, so 00100
So the machine code is:
10011011000001010111110001000100

to hex that is:

9B057C44

Which gives mul x4, x2, x5 in disasm.pro! (little endian so switch order of pairs)

So, if it was being disassembled instead, youd have:
10011011000001010111110001000100

it would extract the relevant parts
Rm = 00101 = 5
Rn = 00010 = 2
Rd = 00100 = 4

Then it would See "is equivalent to" and plug it in those to that so it would give MADD W4, W2, W5, WZR instead

					


Ideas for translation:
Equivalent instructions seem to always be of the form x... "is equivalent to" y... - can use this for parsing
Two ways of defining variables - either can be anything an named in the first row, or name a set bit in the second row
One challenge will be when multiple similar instructions are defined in the same area, all using the same variables
Assembler symbols seems irrelevant
Problem: on equivalent instructions, pseudocode for variables is not given!!!
Once variables are calculated from pseudocode, look at the Assemlber Symbols section, and assign based on "imm12", "Rn" etc. 

Ideas for decoding:
The "Index by Encoding" section has tables that link to each other, effectively forming the decoder tree!


Have to figure out xml parsing of docs
https://github.com/alastairreid/mra_tools/blob/master/bin/instrs2asl.py is a good resource, this seems to have implemented the decode tree



Understanding the encodingindex:
According to the XSL file, the <hierarchy> section contains all the required info to create the decode tree.
Upon inspection, it is formed of nodes, with each "group" node being the instruction class
Taking Reserved for example, the regdiagram appears to be the diagram for the variables, after this is each allocation, with the variable values stored within - using an iclass and then "decode" section
SME encodings on the other hand have many different tables, which seem to be hierarchical and move downwards along the tree 
The XML is defined recursively, each time an instruction is defined, it is a groupname node, and along with the decode format to get match it, is the further tree for all sub categories
So each iclass is purely an instruction class - either unallocated or points to a specific instruction
Groupname is a pointer to an inner decode table
Iclass, such as "mortlach_f64f64_prod" then links to another section in the xml, which in turn stores the xml file name of the instruction, which will then be used for dissasembly
OHH it makes sense - the top level table is the entire thing! thats why groupnames are as such, and thats why theres a decode and diagram at the start of each table, theyre just another groupname

Method to transform this into a decode tree:
So the instruction will be matched to the first table via the top level table, then recursively until an iclass is found
unsure how to turn this into a useful data structure however
since the xml is recursive, then surely the data structure can be constructed recusrively too?
start from the top level table, then move to the next node. 
    if the node is a groupname - start the table creation process again, like if it were top level
    if an iclass, enter this as the value
easy!







INSTRUCTION XML KEY ASPECTS

all contained in an instructionsection tag
docvars tag- info about general page - e.g what instruction set, whats the mnemonic for it, whats the instruction class
desc - text descritpion of the instruction
operationalnotes - human readable notes on the operation of the instruction
alias_list - a list of possible aliases for this instruction? see other instructions for how its formatted
classes- seems to hold the bulk of the instruction info - seems to be one iclass for each instruction encoding held on the page!
    for each class:
        regdiagram, store this as an instructionencoding perhaps? - note that can have variables named as filled values! better set out in xml
        can have multiple encodings - eg for 32 and 64 bits, match against the xml for which
            i think asm template is the instruction? unsure how the links works ://
        then the pseudocode section, also with links

the explanations section is also a KEY part
contains explanations for how each encoding variable links to the asminstruction variables!
nicely machine readable - either a strict mapping OR a definition with a table to match
symbol contains the symbol it is in the asmtemplate, encodedin is the field it actually is!

final psuedocode section not super relevant, as we dont need to simulate the instructions

<alias_list howmany="1">
    <alias_list_intro>This instruction is used by the alias </alias_list_intro>
    <aliasref aliaspageid="MOV_ADD_addsub_imm" aliasfile="mov_add_addsub_imm.xml" hover="Move between register and stack pointer" punct=".">
      <text>MOV (to/from SP)</text>
      <aliaspref>sh == '0' &amp;&amp; imm12 == '000000000000' &amp;&amp; (Rd == '11111' || Rn == '11111')</aliaspref>
    </aliasref>
    <alias_list_outro>
      <text>  See </text>
      <aliastablelink />
      <text> below for details of when the alias is preferred.</text>
    </alias_list_outro>
  </alias_list>

can have aliases, which on certain conditions link to a different instruction.

for now, just store the aliases, can add substituting them based on conditions later on, not as crucial

for 1:1 equivalence, see the <equivalentto> tag in mul_madd.xml.
this is handled in the iclass section!, as specific for each class

how will aliases work?
match all instructions that fit
check which point to which based on alias info
then use this instruction
MORE COMPLEX for stuff like mvn, as orn contains the pseudcode, but it should be showed as mvn..
potential solution: always select the fitting instrction with the most aliases? this shodld give the base instruction, and aliases can then be used for dispaly



NOTE THAT EXPLANATION SECTION MAPS Rd etc. to Wd. etc. machine readable!!


starting to think that pseudocode isnt even strictly necessary?
cant you just use the encodings in the assembly +descriptions?

yeah.. as seen in asr_z_p_zi.xml, even the value table is encoded??!!

aliases will be tricky, but doable.




complex test with vectors:
ldr x4, [x3]
ld1 {v0.4s}, [x0], #16
ld1 {v1.4s}, [x1], #16
st1 {v0.4s}, [x2], #16
subs x4, x4, 4
ret
=
F9400064
4CDF7800
4CDF7821
4C9F7840
F1001084
D65F03C0
=
111110010100000000000000011001000100110011011111011110000000000001001100110111110111100000100001010011001001111101111000010000001111000100000000000100001000010011010110010111110000001111000000

Currently returns
LDR  x4, [x3{, #0}]
LD1  { 0.5 }, [x0], 1
LD1  { 1.5 }, [x1], 1
ST1  { 0.5 }, [x2], 1
SUBS  x4, x4, #4{, 0}
RET  {x30}
HOWEVER, this is due to tables not being implemented yet :) everything else is valid

tables! now returns:
LDR  x4, [x3{, #0}]
LD1  { 0.4S }, [x0], #16
LD1  { 1.4S }, [x1], #16
ST1  { 0.4S }, [x2], #16
SUBS  x4, x4, #4{, LSL #0}
RET  {x30}



ISsue with explanation encodins: often have "off2" field times 2 plus 1. etc.

all encoded as are equations
all encoded in are single fields!!!

verified this with checks when pickling

encoded as ___.

so match the encoded as
get everything between that and the following .
then sub the terms and the symbol!
EZ

can have "o1" field or just "01" SO just strip the word field.

encoded as also includes concatenation with :

after encoded as:

get the string after that until the .
calculate the symbol in "" as usual
replace "..." with the calcualted value
remove field.


naive approach: replace "times", "plus", "modulo" with the characters then calculate
however, potential malicious code execution!
nope. try a simple parser instead. the implementation is ez lol u did it in pldi

okayyy so Equation doesnt work as a lib cause it has good ordering.
going to write my own function as a simple stack. push on each value, (space separated), and apply the following operation to it :)






For aliases need to:
read the aliases
check against the representatio of symbols to binary substrings (in encoding i think), to match to potential aliases
if match, decode instruction explicitly using the class file given

using grep discovered that:
alias conditions can be:
!=
==
&&
(x || y) ( less common though )
Unconditionally
Never
AND symbols can be checked against other symbols values

so must make aliasCondCheck more robust

UNFORTUNATELY after doing all this, turns out there can be things like 011100 != 011111 && 011100 + 1 == 011101
which kind of just screws everything Up
THANKFULLY using grep we can see that there are literally only cases of +1. so we can simply onyl account for this sort of hardcoded

in naive.bin, some constants are incorrect, e.g the lsls
APPEARS TO BE BECAUSE THERE IS "" FOR ENCODEDIN, AND NONE IN THE PARAGRAPH, INSTEAD SHIFT IN SYMBOL SECTION


00010010000000000000010000100001



Using allInstructions has allowed me to iron out bugs in my code!
1st: matchAlias being created due to the break not taking out of the larger loop, resulting in matching the wrong alias
2nd: tables assuming the last entry will be the result, when sometimes can be features instead
3rd: found out that smth like slice<1> can exist not just slice<5:1> so supported this in newResult = result[normIndexes[0]:normIndexes[1]+1]

4th:With asm encodings, sometimes it says no match when there is.this occurs when https://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/LDRB--register---Load-Register-Byte--register--?lang=en
    basically some encoding is used when option != 011, another when option == 011. This is jusut always doing the first, so error when it is 011 and nothing defined for it!
    for now, just made it not quit the program. to make more accurate make it check which encoding to use!!

5th: some instructions dont have any encodings? look into this as ran out of time - sxtw	x16, w15
OMFG. THE ISSUE IS OCCURING BECAUSE THE ALIAS CONDITIONS FOR SBFM ARE OUT OF ORDER - IMMR = AND IMMS = HAS A HIGHER PRESEDENCE OVER IMMS =!!! JUST AWFULLY FORMATTED! WOW
TO FIX: rewrite so aliasMatch returns a list of all possible aliases, and then it goes thru each one and if error, just try next!!!

various occurances of things like (128-UInt(immhimmb)) instead of immediates. more out of scope rather than bug
if plenty of time can add logic for it but its only for specific cases - basically certain vector operations maybe a few dozen

ADD  w14, w4, #3206
should be ADD  w14, w4, #3206, LSL #12
as the table says LSL #12. should be put in. even tho curly braces its not the default!

sucessfully runs all decodings without any crashes!!!! now to note any errors observed in differences:

Around 2430 instructions total tested!
--1. #uimm5 instead of replacing uimm5 with the number it equals for around 60 instructions (2%)
    This occurs in cntb and others. reason: table has #uimm5 as a direct symbol to replace. usually, this would get replaced, but there is no definition of uimm5!!!! seems to be an error in the documentation
    potentially just means the pattern in the left column?? that makes sense lol i might be dumb
2. 64 - uint() etc. for 54 instructions (2%)
3. or support - should pick one or the other with |. unsure how to pick which?
4. fix up the encoding error - choose option and explanation based off the option in the header!
5. mls insutrcitons have binary given at the end, should convert to decimal perhaps
~~6. cpy_z_p_v_ instead of mov? understandable if alias cant match but why give this file name? index_z_rr_ and a bunch of others too! seems to be name of encoding / enclist~~
7. lone SBs?
~~8. STADDLB not having the symbols replaced!!! it is an alias but definitely has the explanations so unknown why they arent being replaced
    same with STCLRLBs and related ones
    BECAUSE EXPLANATIONS ARE BEING ADDED TO STADDLB_LDADDB AND ITS MATCHING WITH STADDLB_LDADDLB
    SEEMS TO BE FULLY AN ARM ERROR.SHOULD INCLUDE BOTH AS OTHER CASES LIKE THIS DO! BUT THIS DOESNT~~
9. count UXTW #0 etc, as defaults to not be shown


To fix 8, i updated to the latest arm documentation and it was fixed!
unfortunately, new issues were created, such as the alias coniditons now having things such as op1 == '011' && CRm IN {'0xx1'} && op2 == '011'
as a temporary fix, decided to simply ignore any conditions with IN in them.
As a result, many more uints appeared!
THIS IS A CRUCIAL THING TO TALK ABT IN REPORT!! CONFIRMS IT WORKS!!!!!!