TODO:
- add special case in explanation decoding for imm5<4:1> to treat it as 4:1st digits of imm5 rather than just imm5<4 ++ 1>
  ^ using regex search, all table entries seem to be normal without extra stuff such as imm5<4:1>:h:Rd etc.
  extremely complex edge case: msr_imm and all related xmls. pseudocode is extremely complex and textual encodings rely on additional factors out of scope - simply cant really do this correctly at this current time
  another edge case: rprfm_reg, where the pseudocode doesnt help and the xml description is very complex and impossible to parse! lots of cases! 
  this is a limitation of the program therefore, BUT it does contain option<2>:option<0>:S:Rt<2:0> indicating this should be supported in case of other interactions

  now, it splits correctly, just have to make it actually accound for the imm5<4:1> stuff properly now in and outside tables

- fix != in some cases
- MANY of the explanations have plaintext such as "encoded as "Zn" times 2 plus 1" etc.
  occasionally with field before the times
  fmlsl_za_zzi for example.
  add checks to translate this into maths expression and perform these on the digits to get right decoding
  even has modulo!
- proper alias treatment - LOOK INTO ALIASPREF section ininstruction page

DONE:
- add explanation to instructionpage class (?)
  -note that explanations can require docvars of the encodings etc.
  - ACTUALLY!!! each explanation has an "enclist" which is the list of encodings it maps to!
  so we simply have to for each explanation check the encoings it applies to and place them in that encoding!
  assumes that expalnations are per class not page - will check this
  no - explanations are per page
  SO, once everything is made, the page can read explanations. for each it will serach through all encodings and add each explanations to the ones they match :)
  https://developer.arm.com/documentation/ddi0602/2023-09/Base-Instructions/AND--immediate---Bitwise-AND--immediate--?lang=en
  - see and_log_shift.xml for example of standard table - 1to1 mapping ebtwen var and value 

Example hand reverse disassembly:
mul x4, x2, x5
Convering to machine code based on spec:
It is equivalent to MADD, However, this is just for when disassembling, and we are doing the opposite.
10011011000Rm011111RnRd
Rm is 5, so 00101
Rn is 2, so 00010
Rd is 4, so 00100
So the machine code is:
10011011000001010111110001000100

to hex that is:

9B057C44

Which gives mul x4, x2, x5 in disasm.pro! (little endian so switch order of pairs)

So, if it was being disassembled instead, youd have:
10011011000001010111110001000100

it would extract the relevant parts
Rm = 00101 = 5
Rn = 00010 = 2
Rd = 00100 = 4

Then it would See "is equivalent to" and plug it in those to that so it would give MADD W4, W2, W5, WZR instead

					


Ideas for translation:
Equivalent instructions seem to always be of the form x... "is equivalent to" y... - can use this for parsing
Two ways of defining variables - either can be anything an named in the first row, or name a set bit in the second row
One challenge will be when multiple similar instructions are defined in the same area, all using the same variables
Assembler symbols seems irrelevant
Problem: on equivalent instructions, pseudocode for variables is not given!!!
Once variables are calculated from pseudocode, look at the Assemlber Symbols section, and assign based on "imm12", "Rn" etc. 

Ideas for decoding:
The "Index by Encoding" section has tables that link to each other, effectively forming the decoder tree!


Have to figure out xml parsing of docs
https://github.com/alastairreid/mra_tools/blob/master/bin/instrs2asl.py is a good resource, this seems to have implemented the decode tree



Understanding the encodingindex:
According to the XSL file, the <hierarchy> section contains all the required info to create the decode tree.
Upon inspection, it is formed of nodes, with each "group" node being the instruction class
Taking Reserved for example, the regdiagram appears to be the diagram for the variables, after this is each allocation, with the variable values stored within - using an iclass and then "decode" section
SME encodings on the other hand have many different tables, which seem to be hierarchical and move downwards along the tree 
The XML is defined recursively, each time an instruction is defined, it is a groupname node, and along with the decode format to get match it, is the further tree for all sub categories
So each iclass is purely an instruction class - either unallocated or points to a specific instruction
Groupname is a pointer to an inner decode table
Iclass, such as "mortlach_f64f64_prod" then links to another section in the xml, which in turn stores the xml file name of the instruction, which will then be used for dissasembly
OHH it makes sense - the top level table is the entire thing! thats why groupnames are as such, and thats why theres a decode and diagram at the start of each table, theyre just another groupname

Method to transform this into a decode tree:
So the instruction will be matched to the first table via the top level table, then recursively until an iclass is found
unsure how to turn this into a useful data structure however
since the xml is recursive, then surely the data structure can be constructed recusrively too?
start from the top level table, then move to the next node. 
    if the node is a groupname - start the table creation process again, like if it were top level
    if an iclass, enter this as the value
easy!







INSTRUCTION XML KEY ASPECTS

all contained in an instructionsection tag
docvars tag- info about general page - e.g what instruction set, whats the mnemonic for it, whats the instruction class
desc - text descritpion of the instruction
operationalnotes - human readable notes on the operation of the instruction
alias_list - a list of possible aliases for this instruction? see other instructions for how its formatted
classes- seems to hold the bulk of the instruction info - seems to be one iclass for each instruction encoding held on the page!
    for each class:
        regdiagram, store this as an instructionencoding perhaps? - note that can have variables named as filled values! better set out in xml
        can have multiple encodings - eg for 32 and 64 bits, match against the xml for which
            i think asm template is the instruction? unsure how the links works ://
        then the pseudocode section, also with links

the explanations section is also a KEY part
contains explanations for how each encoding variable links to the asminstruction variables!
nicely machine readable - either a strict mapping OR a definition with a table to match
symbol contains the symbol it is in the asmtemplate, encodedin is the field it actually is!

final psuedocode section not super relevant, as we dont need to simulate the instructions

<alias_list howmany="1">
    <alias_list_intro>This instruction is used by the alias </alias_list_intro>
    <aliasref aliaspageid="MOV_ADD_addsub_imm" aliasfile="mov_add_addsub_imm.xml" hover="Move between register and stack pointer" punct=".">
      <text>MOV (to/from SP)</text>
      <aliaspref>sh == '0' &amp;&amp; imm12 == '000000000000' &amp;&amp; (Rd == '11111' || Rn == '11111')</aliaspref>
    </aliasref>
    <alias_list_outro>
      <text>  See </text>
      <aliastablelink />
      <text> below for details of when the alias is preferred.</text>
    </alias_list_outro>
  </alias_list>

can have aliases, which on certain conditions link to a different instruction.

for now, just store the aliases, can add substituting them based on conditions later on, not as crucial

for 1:1 equivalence, see the <equivalentto> tag in mul_madd.xml.
this is handled in the iclass section!, as specific for each class

how will aliases work?
match all instructions that fit
check which point to which based on alias info
then use this instruction
MORE COMPLEX for stuff like mvn, as orn contains the pseudcode, but it should be showed as mvn..
potential solution: always select the fitting instrction with the most aliases? this shodld give the base instruction, and aliases can then be used for dispaly



NOTE THAT EXPLANATION SECTION MAPS Rd etc. to Wd. etc. machine readable!!


starting to think that pseudocode isnt even strictly necessary?
cant you just use the encodings in the assembly +descriptions?

yeah.. as seen in asr_z_p_zi.xml, even the value table is encoded??!!

aliases will be tricky, but doable.




complex test with vectors:
ldr x4, [x3]
ld1 {v0.4s}, [x0], #16
ld1 {v1.4s}, [x1], #16
st1 {v0.4s}, [x2], #16
subs x4, x4, 4
ret
=
F9400064
4CDF7800
4CDF7821
4C9F7840
F1001084
D65F03C0
=
111110010100000000000000011001000100110011011111011110000000000001001100110111110111100000100001010011001001111101111000010000001111000100000000000100001000010011010110010111110000001111000000

Currently returns
LDR  x4, [x3{, #0}]
LD1  { 0.5 }, [x0], 1
LD1  { 1.5 }, [x1], 1
ST1  { 0.5 }, [x2], 1
SUBS  x4, x4, #4{, 0}
RET  {x30}
HOWEVER, this is due to tables not being implemented yet :) everything else is valid

tables! now returns:
LDR  x4, [x3{, #0}]
LD1  { 0.4S }, [x0], #16
LD1  { 1.4S }, [x1], #16
ST1  { 0.4S }, [x2], #16
SUBS  x4, x4, #4{, LSL #0}
RET  {x30}



ISsue with explanation encodins: often have "off2" field times 2 plus 1. etc.

all encoded as are equations
all encoded in are single fields!!!

verified this with checks when pickling

encoded as ___.

so match the encoded as
get everything between that and the following .
then sub the terms and the symbol!
EZ

can have "o1" field or just "01" SO just strip the word field.

encoded as also includes concatenation with :

after encoded as:

get the string after that until the .
calculate the symbol in "" as usual
replace "..." with the calcualted value
remove field.


naive approach: replace "times", "plus", "modulo" with the characters then calculate
however, potential malicious code execution!
nope. try a simple parser instead. the implementation is ez lol u did it in pldi

okayyy so Equation doesnt work as a lib cause it has good ordering.
going to write my own function as a simple stack. push on each value, (space separated), and apply the following operation to it :)